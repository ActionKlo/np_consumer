// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: message.sql

package gen

import (
	"context"
	"time"
)

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, time, sender, tracknumber, country, city, street, postcode FROM messages WHERE id = $1
`

func (q *Queries) GetMessageByID(ctx context.Context, id string) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Time,
		&i.Sender,
		&i.Tracknumber,
		&i.Country,
		&i.City,
		&i.Street,
		&i.Postcode,
	)
	return i, err
}

const getMessages = `-- name: GetMessages :many
SELECT id, time, sender, tracknumber, country, city, street, postcode FROM messages
ORDER BY id
`

func (q *Queries) GetMessages(ctx context.Context) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.Sender,
			&i.Tracknumber,
			&i.Country,
			&i.City,
			&i.Street,
			&i.Postcode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMessage = `-- name: InsertMessage :one
INSERT INTO messages (
    id, time, sender, tracknumber, country, city, street, postcode
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) ON CONFLICT (id) DO UPDATE
SET time = excluded.time
RETURNING id, time, sender, tracknumber, country, city, street, postcode
`

type InsertMessageParams struct {
	ID          string
	Time        time.Time
	Sender      string
	Tracknumber string
	Country     string
	City        string
	Street      string
	Postcode    string
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, insertMessage,
		arg.ID,
		arg.Time,
		arg.Sender,
		arg.Tracknumber,
		arg.Country,
		arg.City,
		arg.Street,
		arg.Postcode,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Time,
		&i.Sender,
		&i.Tracknumber,
		&i.Country,
		&i.City,
		&i.Street,
		&i.Postcode,
	)
	return i, err
}

const insertStatus = `-- name: InsertStatus :one
INSERT INTO statuses (
    id, messageid, status, time
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, messageid, status, time
`

type InsertStatusParams struct {
	ID        string
	Messageid string
	Status    string
	Time      time.Time
}

func (q *Queries) InsertStatus(ctx context.Context, arg InsertStatusParams) (Status, error) {
	row := q.db.QueryRowContext(ctx, insertStatus,
		arg.ID,
		arg.Messageid,
		arg.Status,
		arg.Time,
	)
	var i Status
	err := row.Scan(
		&i.ID,
		&i.Messageid,
		&i.Status,
		&i.Time,
	)
	return i, err
}
